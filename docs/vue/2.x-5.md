# vue2.x源码学习(五)
**数据驱动**，Vue.js 一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。它相比我们传统的前端开发，如使用 jQuery 等前端库直接修改 DOM，大大简化了代码量。

当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM，这样的代码非常利于维护。

## 声明式模板语法
渲染DOM示例：
```html
<div id="app">
  {{ message }}
</div>
```
```js
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
```
最终页面会渲染出来<kbd>Hello Vue!</kbd>

## new Vue发生了什么？
new关键字 在Javascript中代表的是的实例化一个对象，Vue实际上是一个类，在Javascript中通过Function来实现。 在<kbd>src/core/instance/index.js</kbd>中。
```js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  //初始化
  this._init(options)
}
```
我们可以看的<kbd>Vue</kbd>只能通过<kbd>new</kbd>关键字来初始化。然后调用<kbd>this._init</kbd>方法,该方法在<kbd>src/core/instance/init.js</kbd>中定义。
```js
export function initMixin (Vue: Class<Component>) {
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    vm._isVue = true
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    //初始化生命周期
    initLifecycle(vm)
    //初始化事件
    initEvents(vm)
    //初始化render
    initRender(vm)
    //调用beforeCreate钩子函数 并且触发钩子事件
    callHook(vm, 'beforeCreate')

    initInjections(vm) // resolve injections before data/props
    //初始化 props、methods、data、computed、 watch
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    //调用created钩子函数 并且触发钩子事件

    callHook(vm, 'created')

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        //格式化组件名
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
        //挂载组件
      vm.$mount(vm.$options.el)
    }
  }
}

```
Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。

W
在初始化的最后，检测到如果有<kbd> el</kbd> 属性，则调用<kbd> vm.$mount</kbd> 方法挂载 <kbd>vm</kbd>，挂载的目标就是把模板渲染成最终的 <kbd>DOM</kbd>，那么接下来我们来分析 Vue 的挂载过程。

## Vue 实例挂载的实现

vue通过<kbd>$mount</kbd>方法挂载<kbd>vm</kbd>的<kbd> $mount</kbd>方法在多个文件中都有定义
<kbd>src/platform/web/entry-runtime-with-compiler.js</kbd>、<kbd>src/platform/web/runtime/index.js</kbd>、<kbd>src/platform/weex/runtime/index.js</kbd>。
<kbd>$mount</kbd>这个方法实现和平台、构建方式都相关。分析带 <kbd>compiler </kbd>版本的 <kbd>$mount</kbd> 实现。



